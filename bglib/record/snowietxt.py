#!/usr/bin/env python
# -*- coding: us-ascii -*-
# vim: syntax=python
#
# Copyright 2006-2009 Noriyuki Hosaka bgnori@gmail.com
#

__all__ = ['Validator']
import sha

from turbogears.decorator import weak_signature_decorator

from tonic.lineparser import LineParser

DEBUG = False

ACCEPTABLES = {
  None: ('handle_mathclength',),
  'handle_emptyline':('handle_gameheader',),
  'handle_mathclength': ('handle_gameheader',),
  'handle_gameheader': ('handle_playerheader',),
  'handle_playerheader': ('handle_moves',),
  'handle_moves': ('handle_moves', 'handle_emptyline', 'handle_gameheader'),
}

def statevalidate(method):
  def entangle(xxx):
    def statevalidate(func, *args, **kw):
      self = args[0]
      current = self.state
      #func.im_self.state
      next = method.__name__
      if next != 'handle_emptyline':
        if next not in ACCEPTABLES[current]:
          if DEBUG:
            print args[1]
          raise ValueError('current:%s, next:%s'%(current, next))
      if current == 'handle_moves' and next == 'handle_moves':
        self.count += 1
      else:
        self.count = 1

      args[0].state = next
      return method(*args, **kw)
    return statevalidate 
  return weak_signature_decorator(entangle)


class LineValidator(LineParser):
  _first = (
  r"""(?P<emptyline>^\s*\Z)"""
  r'|'
  r"""(?P<mathclength>(^ \d+ point match))"""
  r'|'
  r"""(?P<gameheader>(^ *Game \d+))"""
  r'|'
  r"""(?P<playerheader>(^ """
    r"""(?P<player1>[^,:]+(,\d+)? : \d+)"""
    r""" *"""
    r"""(?P<player2>[^,:]+(,\d+)? : \d+)"""
    r""")"""
  r""")"""
  r'|'
  r"""(?P<moves>^ *"""
    r"""(?P<nthmove>\d+)"""
    r"""\) +"""
    r"""(?P<player1_action>"""
      r"""(?P<rolled1>[1-6][1-6]:(?P<move1>( [0-9]{1,2}/[0-9]{1,2}\*?])*))"""
      r'''|'''
      r"""(?P<action1> (Takes)|(Doubles => \d+)|(Drops))"""
      r""")?"""
    r""" *"""
    r"""(?P<player2_action>"""
      r"""(?P<rolled2>[1-6][1-6]:(?P<move2>( [0-9]{1,2}/[0-9]{1,2}\*?])*))"""
      r'''|'''
      r"""(?P<action2> (Takes)|(Doubles => \d+)|(Drops))"""
    r""")?"""
    r""" *"""
    r"""(?P<results1>^ *Wins \d+ points?)?"""
  r""")"""
  r'|'
  r"""(?P<results2>^ *Wins \d+ points?)"""
  )
  _last = r"""(?P<baddata>^.*)"""

  def __init__(self):
    self.state = None
    self.count = None
    
  @statevalidate
  def handle_emptyline(self, match, matchobj):
    if DEBUG:
      print match

  @statevalidate
  def handle_mathclength(self, match, matchobj):
    if DEBUG:
      print match

  @statevalidate
  def handle_gameheader(self, match, matchobj):
    if DEBUG:
      print match

  @statevalidate
  def handle_playerheader(self, match, matchobj):
    if DEBUG:
      print match

  @statevalidate
  def handle_moves(self, match, matchobj):
    if DEBUG:
      print match
    d = matchobj.groupdict()
    if self.count != int(d['nthmove']):
      raise ValueError('Expected %i, but got %s'%(self.count, match))

  def handle_baddata(self, match, matchobj):
    if DEBUG:
      print match
    raise ValueError(match)


class Validator(object):
  def __init__(self, max_size=None):
    self.h = sha.new()
    self.linev = LineValidator()
    self.size = 0
    if max_size is None:
      max_size = 0
    self.max = max_size

  def feed(self, line):
    self.h.update(line)
    self.linev.parse(line)
    self.size += len(line)

  def done(self):
    return self.h

  def validate(self, f):
    for line in f:
      self.feed(line)
      if self.max and self.size >= self.max:
        raise ValueError('Too long content. max is %dK'%self.max)
    return self.done()

def chop(txt):
  linev = LineValidator()
  match_length = 0
  xs = []
  first = True
  for line in txt:
    linev.parse(line)
    if linev.state == 'handle_mathclength':
      match_length = line
      continue
    if linev.state == 'handle_emptyline':
      continue
    if linev.state == 'handle_gameheader':
      if first:
        first = False
      else:
        yield ''.join([match_length, '\n'] + xs)
        xs = []
    xs.append(line)
  yield ''.join([match_length, '\n'] + xs)


if __name__ == '__main__':
  header = '''\
#!/usr/bin/env python
# -*- coding: us-ascii -*-
# vim: syntax=python
#
# Copyright 2006-2009 Noriyuki Hosaka bgnori@gmail.com
#


#WARNING!
#DO NOT EDIT THIS FILE.
#THIS FILE IS AUTO GENERATED.

import random
import StringIO

import unittest
from bglib.record.snowietxt import Validator

def mutated(s, f):
  random.seed(s)
  lines = f.readlines()
  random.shuffle(lines)
  return StringIO.StringIO(''.join(lines))


class SnowietxtTest(unittest.TestCase):
  def setUp(self):
    self.v = Validator()
'''
  vanilla = '''\
  def test_vanilla_%s(self):
    f = open('%s')
    try:
      for line in f:
        self.v.feed(line)
    finally:
      f.close()
    h = self.v.done()
    self.assertEqual(h.hexdigest(),
                     '%s')
'''
  mutated = '''\
  def test_mutated_%s(self):
    f = open('%s')
    m = mutated('%s', f)
    f.close()
    try:
      try:
        for line in m:
          self.v.feed(line)
        self.assert_(False)
      except ValueError:
        pass
    finally:
      m.close()
'''

  import sys
  import tempfile
  from subprocess import call

  f = tempfile.TemporaryFile()
  try:
    call('sha1sum bglib/record/snowietxt/*.txt', shell=True, stdout=f)
    f.seek(0)
    xs = [line.split() for line in f.readlines()]
  finally:
    f.close()

  print header 
  for i, x in enumerate(xs):
    print vanilla%(i, x[1], x[0])

  for i, x in enumerate(xs):
    print mutated%(i, x[1], x[0])

