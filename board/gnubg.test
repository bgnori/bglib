>>> from gnubg import *

>>> encode_position(((6, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1), (0, 3, 2, 2, 2, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0)))
'vzsAAFhu2xFABA'


>>> encode_position(((0, 0, 0, 0, 0, 5, 0, 3, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0), (0, 0, 0, 0, 0, 5, 0, 3, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0)))
'4HPwATDgc/ABMA'

>>> decode_position("vzsAAFhu2xFABA")
((6, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1), (0, 3, 2, 2, 2, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0))

>>> decode_position("4HPwATDgc/ABMA")
((0, 0, 0, 0, 0, 5, 0, 3, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0), (0, 0, 0, 0, 0, 5, 0, 3, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0))


>>> b = BitArray(8, '\x00')
>>> b.endian
'<'
>>> b.binary
'\x00'

>>> b[0]
0
>>> b[7]
0
>>> b[8] #doctest: +ELLIPSIS
Traceback (most recent call last): 
  ...
IndexError: out of range

>>> b['a'] #doctest: +ELLIPSIS
Traceback (most recent call last): 
  ...
TypeError: index must be int

>>> b[0] = 'a'#doctest: +ELLIPSIS
Traceback (most recent call last): 
  ...
ValueError: value for asignment must be 0 or 1


>>> b = BitArray(8, endian='<')
>>> b[7] = 1
>>> b.binary
'\x80'


>>> b = BitArray(8, endian='>')
>>> b.binary
'\x00'
>>> b.endian
'>'

>>> b[0] = 1
>>> b.binary
'\x80'

>>> b = BitArray(8, endian='>')
>>> b[7] = 1
>>> b.binary
'\x01'


>>> b = BitArray(16, endian='<')
>>> b[0] = 1
>>> b.binary
'\x01\x00'

>>> b = BitArray(16, endian='<')
>>> b[15] = 1
>>> b.binary
'\x00\x80'


>>> b = BitArray(16, endian='>')
>>> b[0] = 1
>>> b.binary
'\x80\x00'

>>> b = BitArray(16, endian='>')
>>> b[15] = 1
>>> b.binary
'\x00\x01'


>>> b = BitArray(12, endian='>')
>>> b.binary
'\x00\x00'
>>> b[0] = 1
>>> b.binary
'\x80\x00'

>>> b = BitArray(12, endian='>')
>>> b[11] = 1
>>> b.binary
'\x00\x10'


>>> b = BitArray(12, endian='<')
>>> b.binary
'\x00\x00'
>>> b[0] = 1
>>> b.binary
'\x01\x00'


>>> b = BitArray(12, endian='<')
>>> b[11] = 1
>>> b.binary
'\x00\x08'




This test based on the document from
http://www.gnu.org/manual/gnubg/html_node/A-technical-description-of-the-Match-ID.html

>>> b = MatchProxy('\x41\x89\x2a\x01\x20\x00\x20\x00\x00')
>>> ''.join(map(str, list(b.__dict__['_data'])))
'100000101001000101010100100000000000010000000000000001000000000000'

Bit 1-4 contains the 2-logarithm of the cube value. For example, a 8-cube is encoded as 0011 binary (or 3), since 2 to the power of 3 is 8. The maximum value of the cube in with this encoding is 2 to the power of 15, i.e., a 32768-cube.
>>> b.cube_in_logarithm
1

Bit 5-6 contains the cube owner. 00 if player 0 owns the cube, 01 if player 1 owns the cube, or 11 for a centered cube. 
>>> b.cube_owner
0

Bit 7 is the player on roll or the player who did roll (0 and 1 for player 0 and 1, respectively).
>>> b.on_action
1

Bit 8 is the Crawford flag: 1 if this game is the Crawford game, 0 otherwise.
>>> b.crawford
False

Bit 9-11 is the game state: 000 for no game started, 001 for playing a game, 010 if the game is over, 011 if the game was resigned, or 100 if the game was ended by dropping a cube.
0 000 no game started  < 1
1 001 playing game   1 == 
2 010 games is over  1 < 
3 011 game was resigned
4 100 game was over with pass
>>> b.game_state
1

Bit 12 indicates whose turn it is. For example, suppose player 0 is on roll then bit 7 above will be 0. Player 0 now decides to double, this will make bit 12 equal to 1, since it is now player 1's turn to decide whether she takes or passes the cube.
>>> b.on_inner_action
1

Bit 13 indicates whether an doubled is being offered. 0 if no double is being offered and 1 if a double is being offered.
>>> b.doubled
0

Bit 14-15 indicates whether an resignation was offered. 00 for no resignation, 01 for resign of a single game, 10 for resign of a gammon, or 11 for resign of a backgammon. The player offering the resignation is the inverse of bit 12, e.g., if player 0 resigns a gammon then bit 12 will be 1 (as it is now player 1 now has to decide whether to accept or reject the resignation) and bit 13-14 will be 10 for resign of a gammon.
>>> b.resign_offer
0

Bit 16-18 and bit 19-21 is the first and second die, respectively. 0 if the dice has not yet be rolled, otherwise the binary encoding of the dice, e.g., if 5-2 was rolled bit 16-21 will be 101-010.
>>> b.rolled
(5, 2)

Bitt 22 to 36 is the match length. The maximum value for the match length is 32767. A match score of zero indicates that the game is a money game.
>>> b.match_length
9

Bit 37-51 and bit 52-66 is the score for player 0 and player 1 respectively. The maximum value of the match score is 32767. 
>>> b.score
(2, 4)




